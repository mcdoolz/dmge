<?php
/**
 * @file
 * Link Drupal users with their Patreon accounts.
 */

define('PATREON_USER_OAUTH_CALLBACK_URL', 'patreon_user/oauth');
define('PATREON_USER_NO_LOGIN', 0);
define('PATREON_USER_COPY_ACCOUNT', 1);
define('PATREON_USER_SINGLE_SIGN_ON', 2);
define('PATREON_USER_ONLY_PATRONS', 1);
define('PATREON_USER_ALL_USERS', 2);

/**
 * Implements hook_help().
 */
function patreon_user_help($path, $arg) {
  switch ($path) {
    case 'admin/help#pateon_user':
      return t('<p>The Patreon User module links users with their accounts on <a href="@patreon_url">Patreon</a> service using <a href="@patreon_download_url">their API</a>.</p>', array(
        '@patreon_url' => PATREON_URL,
        '@patreon_download_url' => PATREON_DOWNLOAD_URL,
      ));
  }
}

/**
 * Implements hook_menu().
 */
function patreon_user_menu() {
  $items[PATREON_USER_OAUTH_CALLBACK_URL] = array(
    'title' => 'Patreon User OAuth',
    'access callback' => TRUE,
    'page callback' => 'patreon_user_oauth_callback',
    'type' => MENU_CALLBACK,
    'file' => 'patreon_user.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function patreon_user_form_user_admin_settings_alter(&$form, &$form_state) {
  $section = &$form['registration_cancellation'];
  $position = (array_search('user_register', $section)) ?: count($section) - 1;

  $insert = array(
    'patreon_user_registration' => array(
      '#title' => t('Which Patreon users can log in?'),
      '#description' => t('Select which users you wish to be logged in via the Patreon API.'),
      '#type' => 'radios',
      '#default_value' => variable_get('patreon_user_registration', PATREON_USER_NO_LOGIN),
      '#options' => array(
        PATREON_USER_NO_LOGIN => t('No login via Patreon'),
        PATREON_USER_ONLY_PATRONS => t('Only my patrons'),
        PATREON_USER_ALL_USERS => t('All users from Patreon'),
      ),
    ),
    'patreon_user_login_method' => array(
      '#type' => 'radios',
      '#title' => t('Patreon user login method'),
      '#options' => array(
        PATREON_USER_COPY_ACCOUNT => t('Users must set a Drupal password'),
        PATREON_USER_SINGLE_SIGN_ON => t('Users sign in directly via Patreon'),
      ),
      '#description' => t('Choose whether users must log in as normal via a Drupal account (automatically created via Patreon) or to have users with Patreon accounts automatically logged in without a password.'),
      '#default_value' => variable_get('patreon_user_login_method', PATREON_USER_COPY_ACCOUNT),
      '#states' => array(
        'invisible' => array(
          ':input[name=patreon_user_registration]' => array('value' => PATREON_USER_NO_LOGIN),
        ),
      ),
    ),
  );

  $section = array_slice($section, 0, $position, TRUE) +
    $insert +
    array_slice($section, $position, count($section) - $position, TRUE);
}

/**
 * Implements hook_block_info().
 */
function patreon_user_block_info() {
  $blocks['patreon_user_login'] = array(
    'info' => t('Patreon user log in block'),
    'cache' => DRUPAL_CACHE_PER_ROLE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function patreon_user_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'patreon_user_login':
      if (user_is_anonymous()) {
        if ($settings = (variable_get('patreon_user_registration', 0))) {
          $client_id = variable_get('patreon_client_id', NULL);
          $method = variable_get('patreon_user_login_method', PATREON_USER_COPY_ACCOUNT);

          if ($url = patreon_authorise_account($client_id, patreon_user_get_callback_url(), FALSE)) {
            if ($method == PATREON_USER_COPY_ACCOUNT) {
              $title = t('Register via Patreon');
              $suffix = t('<p>Already registered? <a href="@url">Log in here</a>.</p>', array(
                '@url' => url('/user', array('absolute' => TRUE)),
              ));
            }
            else {
              $title = t('Log on via Patreon');
              $suffix = NULL;
            }
            $block['subject'] = NULL;
            $block['content'] = t('<p><a href="@url">@title</a></p>!suffix', array(
              '@url' => $url,
              '@title' => $title,
              '!suffix' => $suffix,
            ));
          }
        }
      }

      break;
  }

  return $block;
}

/**
 * Helper to return the absolute user oauth callback URL.
 *
 * @return string
 *   The absolute URL of the oauth callback.
 */
function patreon_user_get_callback_url() {
  return url('/' . PATREON_USER_OAUTH_CALLBACK_URL, array('absolute' => TRUE));
}

/**
 * Implements hook_patreon_allowed_callbacks_alter().
 */
function patreon_user_patreon_allowed_callbacks_alter(&$allowed) {
  $allowed[] = patreon_user_get_callback_url();
}

/**
 * Creates the field_user_patreon_id field on the user bundle.
 *
 * @throws \FieldException
 */
function patreon_user_create_user_fields() {
  if (!field_info_field('field_user_patreon_id')) {
    // Create the field base.
    $field = array(
      'field_name' => 'field_user_patreon_id',
      'type' => 'text',
      'locked' => TRUE,
    );
    field_create_field($field);

    // Create the field instance on the bundle.
    $instance = array(
      'field_name' => 'field_user_patreon_id',
      'entity_type' => 'user',
      'label' => 'Patreon ID',
      'bundle' => 'user',
      'required' => FALSE,
      'settings' => array(
        'user_register_form' => 0,
      ),
      'widget' => array(
        'type' => 'textfield',
      ),
    );
    field_create_instance($instance);
  }
  if (!field_info_field('field_user_patreon_access_token')) {
    // Create the field base.
    $field = array(
      'field_name' => 'field_user_patreon_access_token',
      'type' => 'text',
      'locked' => TRUE,
    );
    field_create_field($field);

    // Create the field instance on the bundle.
    $instance = array(
      'field_name' => 'field_user_patreon_access_token',
      'entity_type' => 'user',
      'label' => 'Patreon Token',
      'bundle' => 'user',
      'required' => FALSE,
      'settings' => array(
        'user_register_form' => 0,
      ),
      'widget' => array(
        'type' => 'textfield',
      ),
    );
    field_create_instance($instance);
  }
  if (!field_info_field('field_user_patreon_refresh_token')) {
    // Create the field base.
    $field = array(
      'field_name' => 'field_user_patreon_refresh_token',
      'type' => 'text',
      'locked' => TRUE,
    );
    field_create_field($field);

    // Create the field instance on the bundle.
    $instance = array(
      'field_name' => 'field_user_patreon_refresh_token',
      'entity_type' => 'user',
      'label' => 'Patreon Refresh Token',
      'bundle' => 'user',
      'required' => FALSE,
      'settings' => array(
        'user_register_form' => 0,
      ),
      'widget' => array(
        'type' => 'textfield',
      ),
    );
    field_create_instance($instance);
  }
}

/**
 * Implements hook_field_access().
 */
function patreon_user_field_access($op, $field, $entity_type, $entity, $account) {
  if ($field['field_name'] == 'field_user_patreon_access_token' || $field['field_name'] == 'field_user_patreon_refresh_token') {
    return FALSE;
  }
  if ($field['field_name'] == 'field_user_patreon_id') {
    if ($op == 'edit') {
      return FALSE;
    }
    else {
      return TRUE;
    }
  }
}

/**
 * Creates the Patreon User roles and stores the role id.
 *
 * @param array $roles
 *   Any additional role names that should be created.
 */
function patreon_user_create_role($roles = array()) {
  $bridge = patreon_get_bridge();
  $created = array();

  if ($campaign = patreon_fetch_campaign()) {
    $roles += $bridge->getPatreonRoleNames($campaign);
  }
  foreach ($roles as $role_name => $id) {
    $name = filter_xss($role_name);
    if (!user_role_load_by_name($name)) {
      $role = new stdClass();
      $role->name = $name;
      user_role_save($role);

      if ($role && isset($role->rid)) {
        $created[$name] = $role->rid;
      }
      else {
        watchdog('patreon_user', '@role role could not be created.', array(
          '@role' => $name,
        ), WATCHDOG_WARNING);
      }
    }
  }

  if ($created) {
    variable_set('patreon_user_roles', $created);
  }
}

/**
 * Helper to check whether current Patreon user is allowed to log in.
 *
 * @param \Art4\JsonApiClient\Document $patreon_account
 *   Results from patreon_fetch_user().
 *
 * @return bool
 *   TRUE if user meets current Patreon settings restrictions on log in.
 */
function patreon_user_can_login($patreon_account) {
  $return = FALSE;

  if ($bridge = patreon_get_bridge()) {
    if ($patreon_id = $bridge->getValueByKey($patreon_account, 'data.id')) {
      if ($settings = variable_get('patreon_user_registration', PATREON_USER_NO_LOGIN)) {
        if ($settings != PATREON_USER_NO_LOGIN) {
          if ($settings == PATREON_USER_ONLY_PATRONS) {
            if (patreon_is_patron($patreon_account)) {
              $return = TRUE;
            }
          }
          else {
            $return = TRUE;
          }
        }
      }
    }
  }



  return $return;
}

/**
 * Helper to fetch an existing user or create a new one from Patreon account.
 *
 * @param \Art4\JsonApiClient\Document $patreon_account
 *   Results from patreon_fetch_user().
 *
 * @return bool|object
 *   A Drupal user object, or FALSE on error.
 */
function patreon_user_get_user($patreon_account) {
  $return = FALSE;

  if ($bridge = patreon_get_bridge()) {
    if ($patreon_id = $bridge->getValueByKey($patreon_account, 'data.id')) {
      if ($account = patreon_user_get_user_from_id($patreon_id)) {
        $return = $account;
      }
      else {
        try {
          $return = patreon_user_create_user_from_account($patreon_account);
        }
        catch (\Exception $e) {
          $message = t('We have been unable to create a new user account. The error :error was returned.', array(
            ':error' => $e->getMessage(),
          ));

          drupal_set_message('We have been unable to log you in. Please contact an administrator.');
          watchdog('patreon', $message, array(), WATCHDOG_ERROR);
        }
      }
    }
  }

  return $return;
}

/**
 * Returns a Drupal user account linked to a Patreon account id.
 *
 * @param int $patreon_id
 *   A valid patreon account id.
 *
 * @return object|bool
 *   A Drupal user account, or FALSE if not found.
 */
function patreon_user_get_user_from_id($patreon_id) {
  $return = FALSE;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'user')
    ->fieldCondition('field_user_patreon_id', 'value', $patreon_id, '=')
    ->addMetaData('account', user_load(1));

  $result = $query->execute();

  if (isset($result['user'])) {
    $uids = array_keys($result['user']);

    if (count($uids) > 1) {
      watchdog('patreon_user', 'Multiple users linked to the Patreon account :id', array(':id' => $patreon_id), WATCHDOG_ERROR);
    }
    elseif ($account = entity_load('user', $uids)) {
      $account = reset($account);
      if (isset($account->uid)) {
        if ($account->uid == 1) {
          watchdog('patreon_user', 'Patreon user :id linked to User 1. This could cause security issues.', array(':id' => $patreon_id), WATCHDOG_ERROR);
        }
        $return = $account;
      }
    }
  }

  return $return;
}

/**
 * Creates a Drupal user account from Patreon account data.
 *
 * @param \Art4\JsonApiClient\Document $patreon_account
 *   Results from patreon_fetch_user().
 *
 * @return bool|object
 *   A Drupal user object, or FALSE on error.
 *
 * @throws \Exception
 */
function patreon_user_create_user_from_account($patreon_account) {
  $return = FALSE;

  if ($bridge = patreon_get_bridge()) {
    if ($patreon_id = $bridge->getValueByKey($patreon_account, 'data.id')) {
      $fields = [
        'pass' => user_password(8),
        'status' => 1,
        'access' => REQUEST_TIME,
      ];

      if ($fields['mail'] = filter_xss($bridge->getValueByKey($patreon_account, 'data.attributes.email'))) {
        if (!$existing_mail = user_load_by_mail($fields['mail'])) {
          if ($fields['name'] = filter_xss($bridge->getValueByKey($patreon_account, 'data.attributes.full_name'))) {
            $fields['name'] = $bridge->getUniqueUserName($fields['name'], $patreon_id);

            // Allow other modules to add field data.
            drupal_alter('patreon_user_create_user', $fields, $patreon_account);

            $return = user_save(NULL, $fields);

            if ($return) {
              $wrapper = entity_metadata_wrapper('user', $return);

              if ($wrapper) {
                $wrapper->field_user_patreon_id = filter_xss($patreon_id);
                $wrapper->save();
              }
            }
          }
        }
      }
    }
  }

  return $return;
}

/**
 * Assign the patreon user or deleted patreon user roles based on status.
 *
 * @param object $account
 *   A Drupal user account to update.
 * @param \Art4\JsonApiClient\Document|null $patreon_account
 *   Results array from patreon_fetch_user().
 *
 * @throws \Exception
 */
function patreon_user_assign_roles(&$account, $patreon_account = NULL) {
  if ($bridge = patreon_get_bridge()) {
    $patreon_user_roles = variable_get('patreon_user_roles', array());

    if ($pledges = $bridge->getPatronPledges($patreon_account)) {
      foreach ($pledges as $pledge) {
        foreach ($this->getRelatedRewards($pledge, $patreon_account) as $reward) {
          if ($attributes = $this->getValueByKey($reward, 'attributes')) {
            if ($title = $this->getValueByKey($attributes, 'title')) {
              $role_name = $title . ' Patron';

              if (array_key_exists($role_name, $patreon_user_roles)) {
                $account->roles[$patreon_user_roles[$role_name]] = $role_name;
              }

              unset($patreon_user_roles[$role_name]);
            }
          }
        }
      }
    }
    else {

      // If there are no pledges, we need to make sure the user is only
      // assigned the core roles.
      $patreon_user_roles = array_intersect_key($patreon_user_roles, array(
        'Patreon User' => 0,
        'Deleted Patreon User' => 0,
      ));
    }

    // Because we unset the roles that were matched above, anything left in the
    // array must be a role this user shouldn't have, so let's unset it.
    foreach ($patreon_user_roles as $role_name => $rid) {
      if (array_key_exists($rid, $account->roles)) {
        unset($account->roles[$rid]);
      }
    }

    // Because we deleted all the remaining roles above, our special active or
    // deleted roles will need to be reapplied.
    if ($bridge->isDeletedUser($patreon_account, $account->name)) {
      $account->roles[$patreon_user_roles['Deleted Patreon User']] = 'Deleted Patreon User';
    }
    else {
      $account->roles[$patreon_user_roles['Patreon User']] = 'Patreon User';
    }

    user_save($account);
  }
}
