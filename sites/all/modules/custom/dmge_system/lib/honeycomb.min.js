!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.Honeycomb={})}(this,function(t){"use strict";"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var n,r=(function(t,n){var r;r=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var e=n.length;e--;)t["is"+n[e]]=function(t){return function(n){return r.call(n)===t}}(n[e]);return t},t.exports=r()}(n={exports:{}},n.exports),n.exports),e=r.isObject,i=r.isNumber,o=r.isArray,s=r.isString;function u(t,n){return n+t*(1&n)>>1}function c(t,n){return(t%n+n)%n}function a(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===n&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function f(t,n){return i(t)||i(n)?i(t)?i(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const h={pointy:"pointy",flat:"flat"},l={even:1,odd:-1},d=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],x=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],p={x:1e-6,y:1e-6};function y({ensureXY:t}){const n={add:function({Point:t}){return function(n){return t(this.x+n.x,this.y+n.y)}}({Point:r}),subtract:function({Point:t}){return function(n){return t(this.x-n.x,this.y-n.y)}}({Point:r}),multiply:function({Point:t}){return function(n){return t(this.x*n.x,this.y*n.y)}}({Point:r}),divide:function({Point:t}){return function(n){return t(this.x/n.x,this.y/n.y)}}({Point:r})};function r(r,s){let u;return u=i(r)?t(r,s):o(r)?t(...r):e(r)?t(r.x,r.y):t(0),Object.assign(Object.create(n),u)}return r}const b=Math.sqrt(3);function q(){return{x:this.x,y:this.y}}function g(){return{q:this.q,r:this.r,s:this.s}}function m({q:t,r:n}){let r,e;return this.isPointy()?(r=t+u(this.offset,n),e=n):(r=t,e=n+u(this.offset,t)),{x:r,y:e}}function H({x:t,y:n}){let r,e;return this.isPointy()?(r=t-u(this.offset,n),e=n):(r=t,e=n-u(this.offset,t)),{q:r,r:e,s:-r-e}}function P(){return this.orientation.toLowerCase()===h.pointy}function w(){return this.orientation.toLowerCase()===h.flat}function v(){return 2*this.size}function C(){return b/2*this.oppositeCornerDistance()}function O(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function M(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function S(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function E(){return this.add(p)}function N(){return`${this.x},${this.y}`}var j=function(t,n){var r={};for(var e in t)n.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(r[e]=t[e]);return r},D=function(){return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return function(t,n){var r=[],e=!0,i=!1,o=void 0;try{for(var s,u=t[Symbol.iterator]();!(e=(s=u.next()).done)&&(r.push(s.value),!n||r.length!==n);e=!0);}catch(t){i=!0,o=t}finally{try{!e&&u.return&&u.return()}finally{if(i)throw o}}return r}(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();const G=y({ensureXY:f}),T={thirdCoordinate:function(t,n){return-t-n}};function $(t,n){return t.cartesianToCube({x:t.x,y:t.y})[n]}const W=y({ensureXY:f});class V extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const r=this.length;let e=Number(n);for(t=W(t),e=Math.max(e>=0?e:r+e,0);e<r;e++)if(this[e].equals(t))return e;return-1}lastIndexOf(t,n=this.length-1){const r=this.length;let e=Number(n);for(t=W(t),e=e>=0?Math.min(e,r-1):r+e;e>=0;e--)if(this[e].equals(t))return e;return-1}push(...t){return super.push(...t.filter(V.isValidHex))}splice(t,n,...r){return null==n?super.splice(t):super.splice(t,n,...r.filter(V.isValidHex))}unshift(...t){return super.unshift(...t.filter(V.isValidHex))}}function X(t){return i(t)?this[t]:this[this.indexOf(t)]}function Y(t,n){const r=t.distance(n),e=1/Math.max(r,1);let i=[];for(let o=0;o<=r;o++){const r=t.nudge().lerp(n.nudge(),e*o).round();i.push(this.get(r))}return i}const _=y({ensureXY:f});const z=function({ensureXY:t}){return function(n={}){const r={__isHoneycombHex:!0,orientation:h.pointy,origin:0,size:1,offset:l.odd,get q(){return $(this,"q")},get r(){return $(this,"r")},get s(){return $(this,"s")},add:function({Hex:t,Point:n}){return function(r){var e=n(r);const i=e.x,o=e.y;return t.call(this,this.x+i,this.y+o)}}({Hex:u,Point:G}),cartesian:q,cartesianToCube:H,center:function({Point:t}){return function(){var n=this.origin;const r=n.x,e=n.y;return t(this.width()/2-r,this.height()/2-e)}}({Point:G}),coordinates:q,corners:function({Point:t}){return function(){const n=this.width(),r=this.height();var e=this.origin;const i=e.x,o=e.y;return this.isPointy()?[t(n-i,.25*r-o),t(n-i,.75*r-o),t(.5*n-i,r-o),t(0-i,.75*r-o),t(0-i,.25*r-o),t(.5*n-i,0-o)]:[t(n-i,.5*r-o),t(.75*n-i,r-o),t(.25*n-i,r-o),t(0-i,.5*r-o),t(.25*n-i,0-o),t(.75*n-i,0-o)]}}({Point:G}),cube:g,cubeToCartesian:m,distance:S,equals:function({Point:t}){return function(n){var r=t(n);const e=r.x,i=r.y;return this.x===e&&this.y===i}}({Point:G}),height:M,isFlat:w,isPointy:P,lerp:function({Hex:t}){return function(n,r){const e=this.q*(1-r)+n.q*r,i=this.r*(1-r)+n.r*r;return t.call(this,{q:e,r:i,s:-e-i})}}({Hex:u}),nudge:E,oppositeCornerDistance:v,oppositeSideDistance:C,round:function({Hex:t}){return function(){let n=this.q,r=this.r,e=this.s,i=Math.round(n),o=Math.round(r),s=Math.round(e);const u=Math.abs(n-i),c=Math.abs(r-o),a=Math.abs(e-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,t.call(this,{q:i,r:o,s:s})}}({Hex:u}),set:function({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}({Hex:u}),subtract:function({Hex:t,Point:n}){return function(r){var e=n(r);const i=e.x,o=e.y;return t.call(this,this.x-i,this.y-o)}}({Hex:u,Point:G}),toCartesian:m,toCube:H,toPoint:function({Point:t}){return function(){const n=this.q,r=this.r,e=this.size;let i,o;return this.isPointy()?(i=e*b*(n+r/2),o=3*e/2*r):(i=3*e/2*n,o=e*b*(r+n/2)),t(i,o)}}({Point:G}),toString:N,width:O},s=Object.assign(r,n);function u(n,r,u={}){let c;if(e(n)){let t=n.q,e=n.r,o=n.s,f=j(n,["q","r","s"]);if(i(t)||i(e)||i(o)){if(t+e+o!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${e}, s: ${o}, sum: ${t+e+o}.`);var a=s.cubeToCartesian({q:t,r:e,s:o});c=a.x,r=a.y}else c=n.x,r=n.y;u=f}else if(o(n)){var f=D(n,2);c=f[0],r=f[1],u={}}else c=n;return Object.assign(Object.create(s),this,Object.assign(u,t(c,r)))}return s.origin=G(s.origin),Object.assign(u,T),u}}({ensureXY:f}),A=function({extendHex:t}){return function(n=t()){function r(t,...n){return o(t)?n=t:n.unshift(t),new V(...n.filter(V.isValidHex))}return Object.assign(r,{Hex:n.bind(),isValidHex:function({Grid:t}){return function(n){return t.isValidHex(n)}}({Grid:V}),pointToHex:function({Point:t,Hex:n}){return function(r){const e=n(),i=e.size;var o=t(r).subtract(e.center());const s=o.x,u=o.y;let c,a;return e.isPointy()?(c=(s*Math.sqrt(3)/3-u/3)/i,a=2*u/3/i):(c=2*s/3/i,a=(-s/3+Math.sqrt(3)/3*u)/i),n({q:c,r:a,s:-c-a}).round()}}({Point:_,Hex:n}),parallelogram:function({Grid:t,Hex:n}){return function({width:r,height:e,start:i,direction:o=1,onCreate:s=(()=>{})}){i=n(i);var u=D({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],3);const c=u[0],a=u[1],f=u[2],h=new t;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const e=n(i.cubeToCartesian({[c]:t+i[c],[a]:r+i[a],[f]:-t-r+i[f]}));s(e,h),h.push(e)}return h}}({Grid:V,Hex:n}),triangle:function({Grid:t,Hex:n}){return function({size:r,start:e,direction:i=1,onCreate:o=(()=>{})}){e=n(e);var s={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}}[i];const u=s.rStart,c=s.rEnd,a=new t;for(let t=0;t<r;t++)for(let r=u(t);r<c(t);r++){const i=n(e.cubeToCartesian({q:t+e.q,r:r+e.r,s:-t-r+e.s}));o(i,a),a.push(i)}return a}}({Grid:V,Hex:n}),hexagon:function({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const o=new t;for(let t=-r;t<=r;t++){const s=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=s;r<=u;r++){const s=n(e.cubeToCartesian({q:t+e.q,r:r+e.r,s:-t-r+e.s}));i(s,o),o.push(s)}}return o}}({Grid:V,Hex:n}),rectangle:function({Grid:t,Hex:n,compassToNumberDirection:r,signedModulo:e}){return function({width:i,height:o,start:c,direction:a=(n().isPointy()?0:1),onCreate:f=(()=>{})}){c=n(c),s(a)&&(a=r(a,c.orientation)),(a<0||a>5)&&(a=e(a,6));var h=D([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],3);const l=h[0],d=h[1],x=h[2];var p=c.isPointy()?[i,o]:[o,i],y=D(p,2);const b=y[0],q=y[1],g=new t;for(let t=0;t<q;t++){const r=u(c.offset,t);for(let e=-r;e<b-r;e++){const r=n(c.cubeToCartesian({[l]:e+c[l],[d]:t+c[d],[x]:-e-t+c[x]}));f(r,g),g.push(r)}}return g}}({Grid:V,Hex:n,compassToNumberDirection:a,signedModulo:c})}),Object.assign(V.prototype,{get:X,hexesBetween:Y,neighborsOf:function({Grid:t,signedModulo:n,compassToNumberDirection:r}){return function(e,i="all",o=!1){if(!t.isValidHex(e))throw new Error(`Invalid hex: ${e}.`);const u=o?x:d;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(t=>{s(t)&&(t=r(t,e.orientation)),(t<0||t>5)&&(t=n(t,6));var i=u[t];const o=i.q,c=i.r;return this.get(e.cubeToCartesian({q:e.q+o,r:e.r+c}))}).filter(Boolean)}}({Grid:V,signedModulo:c,compassToNumberDirection:a}),set:function({Grid:t}){return function(n,r){if(!t.isValidHex(r))return this;const e=i(n)?n:this.indexOf(n);return e<0?this.push(r):this[e]=r,this}}({Grid:V})}),r}}({extendHex:z}),I=y({ensureXY:f});t.extendHex=z,t.defineGrid=A,t.Point=I,Object.defineProperty(t,"__esModule",{value:!0})});
